.. Salabim documentation master file, created by
   sphinx-quickstart on Tue Dec 13 08:15:30 2016.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

.. |n| raw:: html

   <br />

.. toctree::
   :maxdepth: 2
   
   Introduction.txt
   Modelling.txt
 
Salabim documentation
=====================
Introduction
------------
Salabim is a package for discrete event simulation in Python.
It follows the methodology of process description as originally demonstrated in *Simula*
and later in *Prosim*, *Must* and *Tomas*. |n|
It is also quite similar to *SimPy 2*.  

The package comprises discrete event simulation, queue handling, resources and statistical sampling.
On top of that real time animation is built in. 

The package comes with a number of sample models.

Requirements
^^^^^^^^^^^^
Salabim runs on

* CPython
* PyPy platform
* Pythonista (iOS)

The package runs under Python 2.7 or 3.x.

The following packages are required:

=============== ================== ================== ================== 
Platform        Base functionality Animation          Video production
=============== ================== ================== ================== 
CPython         -                  PIL                opencv, numpy
PyPy            -                  PIL                N/A
Pythonista      -                  -                  N/A
=============== ================== ================== ================== 

Several CPython packages, like *WinPython* support PIL out of the box. If not, install with:
    ``pip install Pillow``

Under Linux, PIL can be installed with: 
    ``sudo apt-get purge python3-pil`` |n|
    ``sudo apt-get install python3-pil python3-pil.imagetk``

For, video production, installation of opencv and numpy may be required with
    ``pip install opencv-python`` |n|
    ``pip install numpy``
    
Running models under PyPy is highly recommended for production runs,
where run time is important. We have have found 6 to 7 times faster execution compared to CPython.
However, for development, nothing can beat CPython or Pythonista.

Installation
^^^^^^^^^^^^
The preferred way to install salabim is from PyPI with:
  ``pip install salabim``
or to upgrade to a new version:
  ``pip install salabim --upgrade``

You can find the package along with some support files and sample models on www.github.com/salabim/salabim.
From there you can directly download as a zip file and next extract all files. |n|

For Pythonista, the easiest way to install is:

* Tap 'Open in...'.
* Tap 'Run Pythonista Script'.
* Pick this script and tap the run button
* Import file
* Possibly after short delay, there will be a salabim-master.zip file in the root directory
* Tap this zip file and Extract files
* All files are now in a directory called salabim-master
* Optionally rename this directory to salabim

Salabim itself is provided as one Python script, called salabim.py.
You may place that file in any directory where your models reside. |n|

If you want salabim to be available from other directories, without copying the salabim.py script,
run the supplied install.py file.
In doing so, you will create (or update) a salabim directory in the site-package directory,
which will contain a copy of the salabim package.


Python
------
Python is a widely used high-level programming language for general-purpose programming,
created by Guido van Rossum and first released in 1991. An interpreted language, Python has a design
philosophy that emphasizes code readability (notably using whitespace indentation to
delimit code blocks rather than curly brackets or keywords), and a syntax that allows programmers
to express concepts in fewer lines of code than might be used in languages
such as C++ or Java. The language provides constructs intended to enable writing clear programs
on both a small and large scale.

A good way to start learning about Python is https://www.python.org/about/gettingstarted/

Salabim modelling
-----------------
A simple model
^^^^^^^^^^^^^^
Let's start with a very simple model, to demonstrate the basic structure,
process interaction, component definition and output:

.. literalinclude:: ..\..\Example - basic.py

In basic steps:
   
We always start by importing salabim ::

   import salabim as sim

Now we can refer to all salabim classes and function with ``sim.``.
For convenience, some functions or classes can be imported with, for instance ::

   from salabim import now, main, Component

It is also possible to import all methods, classes and globals by ::

   from salabim import *
   
, but we do not recommend that method.

The main body of every salabim model usually starts with ::

   env = sim.Environment(parameters)
   
For each (active) component we define a class as in ::

   class Car(sim.Component):

The class inherits from sim.Component.

Although it is possible to define other processes within a class,
the standard way is to define a generator function called ``process`` in the class.
A generator is a function with at least one yield statement. These are used in salabim context as
a signal to give control to the sequence mechanism.

In this example, ::

   yield self.hold(1)

gives control,to the sequence mechanism and *comes back* after 1 time unit. The self. part means that
it is this component to be held for some time. We will see later other uses of yield like passivate,
request, wait and standby.

In the main body an instance of a car is created by Car(). It automatically gets the name car.0.
As there is a generator function called
process in Car, this process description will be activated (by default at time now, which is 0 here).
It is possible to start a process later, but this is by far the most common way to start a process.

With ::

   env.run(till=5)

we start the simulation and get back control after 5 time units. A component called *main* is defined
under the hood to get access to the main process.

When we run this program, we get the following output ::

         0.000 main                 current                              
                                    car create                           
                                    car activate                         scheduled for      0.000 @process
                                    main run                             scheduled for      5.000
         0.000 car                  current                              
                                    car hold                             scheduled for      1.000
         1.000 car                  current                              
                                    car hold                             scheduled for      2.000
         2.000 car                  current                              
                                    car hold                             scheduled for      3.000
         3.000 car                  current                              
                                    car hold                             scheduled for      4.000
         4.000 car                  current                              
                                    car hold                             scheduled for      5.000
         5.000 main                 current                              


A bank example
^^^^^^^^^^^^^^
Now let's move to a more realistic model. Here customers are arriving in
a bank, where there is one clerk. This clerk handles the
customers in first in first out (fifo) order.
We see the following processes:

- The customer generator that creates the customers, with an inter arrival time of uniform(5,15)
- The customers
- The clerk, which serves the customers in a constant time of 30 (overloaded and non steady state system)

And we need one queue for the customers to wait for service.

The model code is:

.. literalinclude:: ..\..\Example - bank, 1 clerk.py

Let's look at some details ::

   yield self.hold(sim.Uniform(5, 15).sample())

will do the statistical sampling and wait for that time till the next customer is created.

With ::

   self.enter(waitingline)

the customer places itself at the tail of the waiting line.

Then, the customer check whether the clerk is idle, and if so, reactivates him immediately. ::

    while clerk.ispassive():
        clerk.reactivate()

And then the customer is going to wait for a reactivation (by the clerk) and then leaves the queue ::

    yield self.passivate()
    self.leave(waitingline)

In the main section of the program, we create the CustomerGenerator, the Clerk and a queue called waitingline.
After the simulation is finished, the statistics of the queue are presented with ::

    waitingline.print_statistics()

The output looks like ::

         0.000 main                 current                              
                                    customergenerator create             
                                    customergenerator activate           scheduled for      0.000 @process
                                    clerk create                         
                                    clerk activate                       scheduled for      0.000 @process
                                    waitingline create                   
                                    main run                             scheduled for     50.000
         0.000 customergenerator    current                              
                                    customer create                      
                                    customer activate                    scheduled for      0.000 @process
                                    customergenerator hold               scheduled for     14.631
         0.000 clerk                current                              
                                    clerk passivate                      
         0.000 customer             current                              
                                    customer                             enter waitingline
                                    clerk activate                       scheduled for      0.000
                                    customer passivate                   
         0.000 clerk                current                              
                                    customer                             leave waitingline
                                    clerk hold                           scheduled for     30.000
        14.631 customergenerator    current                              
                                    customer rename to customer.0        
                                    customer.1 create                    
                                    customer.1 activate                  scheduled for     14.631 @process
                                    customergenerator hold               scheduled for     21.989
        14.631 customer.1           current                              
                                    customer.1                           enter waitingline
                                    customer.1 passivate                 
        21.989 customergenerator    current                              
                                    customer.2 create                    
                                    customer.2 activate                  scheduled for     21.989 @process
                                    customergenerator hold               scheduled for     32.804
        21.989 customer.2           current                              
                                    customer.2                           enter waitingline
                                    customer.2 passivate                 
        30.000 clerk                current                              
                                    customer.0 activate                  scheduled for     30.000
                                    customer.1                           leave waitingline
                                    clerk hold                           scheduled for     60.000
        30.000 customer.0           current                              
        30.000 customer.0           ended                                
        32.804 customergenerator    current                              
                                    customer.3 create                    
                                    customer.3 activate                  scheduled for     32.804 @process
                                    customergenerator hold               scheduled for     40.071
        32.804 customer.3           current                              
                                    customer.3                           enter waitingline
                                    customer.3 passivate                 
        40.071 customergenerator    current                              
                                    customer.4 create                    
                                    customer.4 activate                  scheduled for     40.071 @process
                                    customergenerator hold               scheduled for     54.737
        40.071 customer.4           current                              
                                    customer.4                           enter waitingline
                                    customer.4 passivate                 
        50.000 main                 current                              

    Statistics of waitingline at        50    
                                                                         all    excl.zero         zero
    -------------------------------------------- -------------- ------------ ------------ ------------
    Length of waitingline                        duration             50           35.369       14.631
                                                 mean                  1.410        1.993
                                                 std.deviation         1.107        0.754

                                                 minimum               0            1    
                                                 median                2            2    
                                                 90% percentile        3            3    
                                                 95% percentile        3            3    
                                                 maximum               3            3    

    Length of stay in waitingline                entries               2            1            1    
                                                 mean                  7.684       15.369
                                                 std.deviation         7.684        0    

                                                 minimum               0           15.369
                                                 median               15.369       15.369
                                                 90% percentile       15.369       15.369
                                                 95% percentile       15.369       15.369
                                                 maximum              15.369       15.369

Now, let's add more clerks. Here we have chosen to put the three clerks in a Queue,
although in this case it could have been also a Python list ::

    clerks = sim.Queue('clerks')
    for i in range(3):
        Clerk().enter(clerks)

And, to restart a clerk ::

    for clerk in clerks:
        if clerk.ispassive():
           clerk.reactivate()
           break  # reactivate only one clerk
        
The complete source of a three clerk post office:

.. literalinclude:: ..\..\Example - bank, 3 clerks.py
    
A bank office example with resources
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
The salabim package contains another useful concept for modelling: resources.
Resources have a limited capacity and can be claimed by components and released later. 

In the model of the bank with the same functionality as the above example, the 
clerks are defined as a resource with capacity 3.

The model code is:

.. literalinclude:: ..\..\Example - bank, 3 clerks (resources).py

Let's look at some details. ::

   clerks = sim.Resource('clerks', capacity=3)
   
This defines a resource with a capacity of 3.

And then, a customer, just tries to claim one unit (=clerk) from the resource with ::

    yield self.request(clerks)
    
Here, we use the default of 1 unit. If the resource is not available, the customer just
waits for it to become available (in order of arrival, here).

In contrast with the previous example, the customer now holds itself for 10 time units.

And after these 10 time units, the customer releases the resource with ::

    self.release()
    
The effect is that salabim then tries to honor the next pending request, if any.

The statistics are maintained in a system queue, called clerk.requesters().

The output is very similar to the earlier example. The statistics are exactly the same.

The bank office example with balking and reneging
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Now, we assume that clients are not going to the queue when there are more than 5 clients
waiting (balking). On top of that, if a client is waiting longer than 50, he will
leave as well (reneging).

The model code is:

.. literalinclude:: ..\..\Example - bank, 3 clerks, reneging.py

Let's look at some details. ::

   yield self.cancel()
   
This makes the current component (a customer) a data component (and be subject to 
garbage collection), if the queue length is 5 or more.

The reneging is implemented by a hold of 50. If a clerk can service a customer, it will take
the customer out of the waitingline and will activate it at that moment. The customer just has to check
whether he is still in the waiting line. If so, he has been serviced in time and thus will renege. ::

   yield self.hold(50)
   if self in waitingline:
       self.leave(waitingline)
       env.number_reneged += 1
   else:
        self.passivate()
        
All the clerk has to do when starting servicing a client is to get the next customer in line 
out of the queue (as before) and activate this customer (at time now). The effect is that the hold
of the customer will end. ::

   self.customer = waitingline.pop()
   self.customer.activate()
   
The bank office example with balking and reneging (resources)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Now we show how the balking and reneging is implemented with resources.
   
The model code is:

.. literalinclude:: ..\..\Example - bank, 3 clerks, reneging (resources).py

As you can see, the balking part is exactly the same as in the example without resources.

For the renenging, all we have to do is add a fail_delay ::

   yield self.request(clerks, fail_delay=50)

If the request is not honored within 50 time units, the process continues after that request statement.
And then, we just check whether the request has failed ::

   if self.failed():
       env.number_reneged += 1
       
This example shows clearly the advantage of the resource solution over the passivate/activate method.
  
A bank office example with states
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
The salabim package contains yet another useful concept for modelling: states.
In this case, we define a state called worktodo.

The model code is:

.. literalinclude:: ..\..\Example - bank, 3 clerks (state).py

Let's look at some details. ::

   worktodo = sim.State('worktodo')
   
This defines a state with an initial value False.

In the code of the customer, the customer tries to trigger one clerk with ::

   worktodo.trigger(max=1)

The effect is that if there are clerks waiting for worktodo, the first clerk's wait is honored and
that clerk continues its process after ::

   yield self.wait(worktodo)
   
Note that the clerk is only going to wait for worktodo after completion of a job if there
are no customers waiting.

   
Component
---------
General
^^^^^^^
Components are the key element of salabim simulations.

Components can be either data or active. An active component has one or more process descriptions and is activated
at some point of time. You can make a data component active with activate. And an active component can become
data either with a cancel or by reaching the end of its process method.

It is easy to create a data component by:

.. code-block:: python

   box = sim.Component()
   
Data components may be placed in a queue. You can't activate this component as such as there is no associated process method.

In order to make an active component it is necessary to first define a class:

.. code-block:: python

   class Ship(sim.Component):
    
And then there has to be at least one generator method, normally called process:

.. code-block:: python

   class Ship(sim.Component):
       def process(self):
           ....
           yield ...
           ....
           
The process has to have at least one yield statement!
 
Creation and activation can be combined by making a new instance of the class:

.. code-block:: python

   ship1 = Ship()
   ship2 = Ship()
   ship3 = Ship()
   
This causes three Ships to be created and to start them at Sim.process().
The ships will automatically get the name ``ship.1``, etc., unless a name
is given explicitly. If only one ship is created it will get the name ``ship``.

If no process method is found for Ship, the ship will be a data component.
In that case, it becomes active by means of an activate statement:

.. code-block:: python

   class Crane(sim.Component):
       def unload(self):
           ....
           yield ...
           ....

   crane1 = Crane()
   crane1.activate(process='unload')
   
   crane2 = Crane(process='unload')

Effectively the effect of the creation and start of crane1 and crane2 is the same.
   
Although not very common, it is possible to activate a component at a certain time or with a 
specified delay:

.. code-block:: python

   ship1.activate(at=100)
   ship2.activate(delay(50))
   
At time of creation it is sometimes useful to be able to set attributes, prepare for actions, etc.
This is possible in salabim by defining an __init__ and/or a setup method:

If the __init__ method is used, it is required to call the Component __init__ method from within the
overridden method:

.. code-block:: python

   class Ship(sim.Component):
       def __init__(self, length):
           sim.Component.__init__(self)
           self.length = length
           
   ship = Ship(length=250)
   
This sets ship.length to 250.

In most cases, the setup method is preferred however. This method is called after ALL initialization code
of Component is executed.

.. code-block:: python

   class Ship(sim.Component):
       def setup(self,length):
           self.length = length
           
   ship = Ship(length=250)
   
Now, ship.length will be 250.
   
Only in very specific cases, __init__ will be necessary.

Note that the setup code can be used for data components as well.

Process interaction
^^^^^^^^^^^^^^^^^^^
It is important to realize that a component may be in one of the following states:

* data
* current
* scheduled
* passive
* requesting
* waiting
* standby

The scheme below shows how components can go from state to state.

========== ============ ============ ============== =============== ============= ============ =============
from/to    data         current      scheduled      passive         requesting    waiting      standby
========== ============ ============ ============== =============== ============= ============ =============
data                    activate[1]  activate 
current    process end               yield hold     yield passivate yield request yield wait   yield standby 
           yield cancel              yield activate                               
scheduled  cancel       next event   hold           passivate       request       wait         standby
                                     activate
passive    cancel       activate[1]  activate                       request       wait         standby
                                     hold[2]
requesting cancel       claim honor  activate[3]    passivate       request       wait         standby
                        time out                                    activate[4]
waiting    cancel       wait honor   acivate[5]     passivate       wait          wait         standby
                        timeout                                                   activate[6]
standby    cancel       next event   activate       passivate       request       wait              
========== ============ ============ ============== =============== ============= ============ =============

[1] via scheduled |n|
[2] not recommended |n|
[3] with keep_request=False (default) |n|
[4] with keep_request=True. This allows to set a new time out
[5] with keep_wait=False (default) |n|
[6] with keep_wait=True. This allows to set a new time out

Creation of a component
~~~~~~~~~~~~~~~~~~~~~~~
Although it is possible to create a component directly with `x=sim.Component()`, but 
then it’s virtually impossible to make that component into a non data component,
because there’s no process method. So, nearly always we define a class based on
sim.Component ::
    
    def Car(sim.Component):
        def process(self):
            ...
            
If we then say `car=Car()`, a component is created and it activated from process. This
process has to be a generator function, so needs to contain at least one yield statemement.

The result is that car is put on the future event list (for time now) and when it’s its
turn, the component becomes current.

It is also possible to set a time at which the component (car) becomes active, like `car=Car(at=10)`.

And instead of starting at process, the component may be initialized to start at another generation function,
like `car=Car(process='wash')`.

And, finally, if there is a process method, you can disable the automatic activation (i.e.
make it a data component) , by specifying `process=None`.

If there is no process method, and process= is not given, the component becomes a data component.

activate
~~~~~~~~
Activate is the way to turn a data component into a live component. If you do not specify a process,
the generator function process is assumed. So you can say ::

    car0 = Car(process=None)  # data component
    car0.activate()  # activate @ process if exists, otherwise error
    car1 = Car(process=None)  # data component
    car1.activate(process='wash')  # activate @ wash
    
* If the component to be activated is current, always use yield self.activate. The effect is that the
  component becomes scheduled, thus this is essentially equivalent to the preferred hold method.
* If the component to be activated is passive, the component will be activated at the specified time.
* If the component to be activated is scheduled, the component will get a new scheduled time.
* If the component to be activated is requesting, the request will be
  terminated, the attribute failed set and the component will become scheduled. If keep_request=True
  is specified, only the fail_at will be updated and the component will stay requesting.
* If the component to be activated is waiting, the wait will be
  terminated, the attribute failed set and the component will become scheduled. If keep_wait=True
  is specified, only the fail_at will be updated and the component will stay waiting.
* If the component to be activated is standby, the component will get a new scheduled time and become
  scheduled.
  
hold
~~~~
Hold is the way to make a, usually current, component scheduled.

* If the component to be held is current, the component becomes scheduled for the specified time. Always
  use yield self.hold() is this case.
* If the component to be held is passive, the component becomes scheduled for the specified time.
* If the component to be held is scheduled, the component will be rescheduled for the specified time, thus
  essentially the same as activate.
* If the component to be held is standby, the component becomes scheduled for the specified time.
* If the component to be activated is requesting, the request will be terminated, the attribute failed 
  set and the component will become scheduled. It is recommended to use the more versatile activate method.
* If the component to be activated is waiting, the wait will be
  terminated, the attribute failed set and the component will become scheduled. It is recommended to
  use the more versatile activate method.

passivate
~~~~~~~~~
Passivate is the way to make a, usually current, component passive. This is actually the
same as scheduling for time=inf.

* If the component to be passivated is current, the component becomes passive. Always
  use yield seld.passivate() is this case.
* If the component to be passivated is passive, the component remains passive.
* If the component to be passivated is scheduled, the component will be passivated.
* If the component to be held is standby, the component will be passivated.
* If the component to be activated is requesting, the request will be terminated, the attribute failed 
  set and the component will become pass It is recommended to use the more versatile activate method.
* If the component to be activated is waiting, the wait will be
  terminated, the attribute failed set and the component will become scheduled. It is recommended to
  use the more versatile activate method.

cancel
~~~~~~
Cancel has the effect that the component becomes a data component.

* If the component to be cancelled is current, use always yield self.cancel().
* If the component to be cancelled is requesting, the request will be terminated, the attribute failed 
  set and the component will become a data component.
* If the component to be cancelled is waiting, the wait will be terminated, the attribute failed 
  set and the component will become a data component.

standby
~~~~~~~
Standby is a 

request
~~~~~~~

wait
~~~~

Queue
-----
Salabim has a class Queue for queue handling of component. The advantage over the standard list and deque are:

* double linked, resulting in easy and efficient insertion at any place
* data collection
* priority sorting

Salabim uses queues internally for resource and states as well.

Definition of a queue is simple:

.. code-block:: python

   waitingline=sim.Queue('waitingline')
   
There is a set of methods for components to enter and leave a queue:

======================== ======================== =========================================
Component                Queue                    Description
======================== ======================== =========================================
c.enter(q)               q.add(c)                 c enters q at the tail
c.enter_to_head(q)       q.add_at_head(c)         c enters q at the head
c.enter_in_front(q, c1)  q.add_in_front_of(c, c1) c enters q in front of c1
c.enter_behind(q, c1)    q.add_behind(c, c1)`     c enters q behind c1
c.enter_sorted(q, p)     q.add_sorted(c, p)       c enters q according to priority p
c.leave(q)               q.remove(c)              c leaves q

======================== ==================================================================

The head a queue can be retrieved with ``q.head()``. If a queue is empty, None will be returned. |n|
The tail a queue can be retrieved with ``q.tail()``. If a queue is empty, None will be returned. |n|
To remove the head of a queue, use ``pop(q)``. The component at the head will be returned (None if queue is empty).
The successor of a component in queue can be retrieved with ``c.successor(q)`` or ``q.successor(c)`` |n|
The predecessor of a component in queue can be retrieved with ``c.predecessor(q)`` or ``q.predecessor(c)`` |n|

Queue is a standard ABC class, which means that the following methods are supported:
``len(q)`` to retrieve the length of a queue, alternatively via the timestamped monitor with ``)q.length()``
``c in q`` to check whether a component is in a queue
``for c in q:`` to traverse a queue (it is even possible to remove and add components in the for body.
``for c in reverse(q)`` to traverse a queue from tail to head

Salabim keeps track of the enter time in a queue: ``c.enter_time(q)``

Unless disabled explicitly, the length of the queue and length of stay of components is monitored in 
``q.length`` and ``q.length_of_stay``. It is possible to obtain a number of statistics on these monitors (cf. Monitor).

With ``q.print_statistics()`` the key statistics of these two monitors are printed.

E.g.:

.. code-block:: none

    -------------------------------------------- -------------- ------------ ------------ ------------
    Length of waitingline                        duration          50000        48499.381     1500.619
                                                 mean                  8.427        8.687
                                                 std.deviation         4.852        4.691

                                                 minimum               0            1    
                                                 median                9           10    
                                                 90% percentile       14           14    
                                                 95% percentile       16           16    
                                                 maximum              21           21    

    Length of stay in waitingline                entries            4995         4933           62    
                                                 mean                 84.345       85.405
                                                 std.deviation        48.309       47.672

                                                 minimum               0            0.006
                                                 median               94.843       95.411
                                                 90% percentile      142.751      142.975
                                                 95% percentile      157.467      157.611
                                                 maximum             202.153      202.153
                                                 
With ``q.print_info()`` a summary of the contents of a queue can be printed.

E.g.

.. code-block:: none

    Queue 0x20e116153c8
      name=waitingline
      component(s):
        customer.4995        enter_time 49978.472 priority=0
        customer.4996        enter_time 49991.298 priority=0
                                                 
Resource
--------
Resources are a powerful way of process interaction. 

A resource has always a capacity (which can be zero). This capacity will be specified at time of creation, but
may change over time.
There are two of types resources:
* standard resources, where each claim is associated with a component (the claimer). It is not
necessary that the claimed quantities are integer.
* anonymous resources, where only the claimed quantity is registered. This is most useful for dealing with levels, lengths, etc.

Resources are defined like:

.. code-block:: python

    clerks = Resource('clerks', capacity=3)

And then a component can request a clerk:

.. code-block:: python

    yield self.request(clerks)  # request 1 from clerks 
    
It is also possible to request for more resources at once:

.. code-block:: python

    yield self.request(clerks,(assistance,2))  # request 1 from clerks AND 2 from assistance

Resources have a queue ``requesters`` containing all components try to claim from the resource.
And a queue ``claimers`` containing all components claiming from the resource
(not for anonymous resources).

It is possible to release a quantity from a resource with c.release(), e.g.

.. code-block:: python

    self.release(r)  # releases all claimed quantity from r
    self.release((r,2))  # release quantity 2 from r
    
Alternatively, it is possible to release from a resource directly, e.g.

.. code-block:: python

    r.release()  # releases the total quantity from all claiming components
    r.release(10)  # releases 10 from the resource; only valid for anonymous resources
    
After a release, for all requesting components will be checked whether their claim can be honored.

Resources have a number of monitors and timestamped monitors:

* claimers().length
* claimers().length_of_stay
* requesters().length
* requesters().length_of_stay
* claimed_quantity
* available_quantity
* capacity

By default, all monitors are enabled.

With ``r.print_statistics()`` the key statistics of these all monitors are printed.

E.g.:

.. code-block:: none

    Statistics of clerk at     50000.000
                                                                         all    excl.zero         zero
    -------------------------------------------- -------------- ------------ ------------ ------------
    Length of requesters of clerk                duration          50000        48499.381     1500.619
                                                 mean                  8.427        8.687
                                                 std.deviation         4.852        4.691

                                                 minimum               0            1    
                                                 median                9           10    
                                                 90% percentile       14           14    
                                                 95% percentile       16           16    
                                                 maximum              21           21    

    Length of stay in requesters of clerk        entries            4995         4933           62    
                                                 mean                 84.345       85.405
                                                 std.deviation        48.309       47.672

                                                 minimum               0            0.006
                                                 median               94.843       95.411
                                                 90% percentile      142.751      142.975
                                                 95% percentile      157.467      157.611
                                                 maximum             202.153      202.153

    Length of claimers of clerk                  duration          50000        50000            0    
                                                 mean                  2.996        2.996
                                                 std.deviation         0.068        0.068

                                                 minimum               1            1    
                                                 median                3            3    
                                                 90% percentile        3            3    
                                                 95% percentile        3            3    
                                                 maximum               3            3    

    Length of stay in claimers of clerk          entries            4992         4992            0    
                                                 mean                 30           30    
                                                 std.deviation         0.000        0.000

                                                 minimum              30.000       30.000
                                                 median               30           30    
                                                 90% percentile       30           30    
                                                 95% percentile       30           30    
                                                 maximum              30.000       30.000

    Capacity of clerk                            duration          50000        50000            0    
                                                 mean                  3            3    
                                                 std.deviation         0            0    

                                                 minimum               3            3    
                                                 median                3            3    
                                                 90% percentile        3            3    
                                                 95% percentile        3            3    
                                                 maximum               3            3    

    Available quantity of clerk                  duration          50000          187.145    49812.855
                                                 mean                  0.004        1.078
                                                 std.deviation         0.068        0.268

                                                 minimum               0            1    
                                                 median                0            1    
                                                 90% percentile        0            1    
                                                 95% percentile        0            2    
                                                 maximum               2            2    

    Claimed quantity of clerk                    duration          50000        50000            0    
                                                 mean                  2.996        2.996
                                                 std.deviation         0.068        0.068

                                                 minimum               1            1    
                                                 median                3            3    
                                                 90% percentile        3            3    
                                                 95% percentile        3            3    
                                                 maximum               3            3      
                                             
With ``r.print_info()`` a summary of the contents of a queue can be printed.

E.g.

.. code-block:: none

    Resource 0x112e8f0b8
      name=clerk
      capacity=3
      requesting component(s):
        customer.4995        quantity=1
        customer.4996        quantity=1
      claimed_quantity=3
      claimed by:
        customer.4992        quantity=1
        customer.4993        quantity=1
        customer.4994        quantity=1
        
The capacity may be changed with ``r.set_capacity(x)``. Note that this may lead to requesting
components to be honored.

Querying of the capacity, claimed quantity and available quantity can be done via the timestamped monitors:
``r.capacity()``, ``r.claimed_quantity()`` and ``r.available_quantity()``

State
-----
States together with the Component.wait method provide a powerful way of process interaction. 

A state will have a certain value at a given time. In its simplest form a component can then wait for
a specific value of a state. Once that value is reached, the compoent will be resumed.

Definition is simple, like ``dooropen=sim.State('dooropen')``. The default initial value is False, meaning
the door is closed.

Now we can say ::

    dooropen.set()

to open the door.

If we want a person to wait for an open door, we could say ::

    yield self.wait(dooropen)
    
If we just want at most one person to enter, we say ``dooropen.trigger(max=1)``.

We can obtain the current value by just calling the state, like in ::

    print('door is ',('open' if dooropen() else 'closed'))

Alternatively, we can get the current value with the get method ::

  print('door is ',('open' if dooropen.get() else 'closed'))

The state is automatically monitored in the state.value timestamped monitor.

States can be used also for non values other than bool type. E.g. ::

    light=sim.State('light', value='red')
    ...
    light.state.set('green')

Or define a int/float state ::

    level=sim.State('level', value=0)
    ...
    level.set(level()+10)

The state value will be monitored and therefore, statistical information and
histograms will be available.

Process interaction with wait()
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
A component can wait for a state to get a certain value. In its most simple form ::

    yield self.wait(dooropen)
    
Once the dooropen state is True, the component will continue.

As with request() it is possible to set a timeout with fail_at or fail_delay ::

    yield self.wait(dooropen, fail_delay=10)
    if self.failed:
        print('impatient ...')
        
In the above example we tested for a state to be True. 

There are three ways to test for a value:

Scalar testing
~~~~~~~~~~~~~~
It is possible (and even more common) to
test for a certain value ::

    yield self.wait((light, 'green'))
    
Or more states at once ::
    
    yield self.wait((light, 'green'), night)  # honored as soon as light is green OR it's night
    yield self.wait((light, 'green'), (light, 'yellow'))  # honored as soon is light is green OR yellow
    
It is also possible to wait for all conditions to be satisfied, by adding ``all=True``::

    yield self.wait((light,'green'), enginerunning, all=True)  # honored as soon as light is green AND engine is running
    
Evaluation testing
~~~~~~~~~~~~~~~~~~
Here, we use a string containing an expression that can evaluate to True or False. This is
done by specifying at least one ``$`` in the test-string. This ``$`` will be replaced at run time by
``state.value()``, where state is the state under test. Here are some examples ::

    yield self.wait((light, '$ in ("green","yellow")')) 
        # if at run time light.value() is 'green', test for eval(state.value() in ("green,"yellow")) ==> True
    yield self.wait((level, '$ < 30'))
        # if at run time level.value() is 50, test for eval(state.value() < 30) ==> False
        
During the evaluation, ``self`` refers to the component under test and ``state`` to the state under test.
E.g. ::

    self.limit = 30
    yield self.wait((level, 'self.limit >= $'))
        # if at run time level.value() is 50, test for eval(self.limit >= state.value()) ==> False
        
Function testing
~~~~~~~~~~~~~~~~
This is a more complicated but also more versatile way of specifying the honor-condition.
In that case, a function is required to specify the condition. The function needs to accept three
arguments:

* x = state.value()
* component component under test
* state under test

E.g.::
        
    yield self.wait((light, lambda x, _, _: x in ('green', 'yellow'))
        # x is light.value()
    yield self.wait((level, lambda x, _, _: x < 30))
        # x is light.value()
        
And, of course, it is possible to define a function ::

    def levelreached(x):
        value, component, _ = x
        return value < component.limit
        
    ...
    
    self.limit = 30
    yield self.wait((level, levelreached))
    
Combination of testing methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
It is possible to mix scalar, evaluation and function testing. And it's also possible to specify all=True
in any case.  

Monitor and MonitorTimestamp
----------------------------
Monitors and timestamped monitors are a way to collect data from the simulation. They are automatically collected
for resources, queues and states. On top of that the user can define its own (timestamped) monitors.

Monitor
^^^^^^^
The Monitor class collects values which do not have a direct relation with the current time, 
e.g. the processing time of a part.

We define the monitor with ``processingtime=sim.Monitor('processingtime')`` and then
collect values by ``processingtime.tally(env.now()-start)``

There is whole set of statistical data available:

* number_of_entries
* number_of_entries_zero
* mean
* std
* minimum
* median
* maximum
* percentile 
* bin_count (number of entries between to given values)
* histogram (numpy definition)

For all these statistics, it is possible to exclude zero entries, 
e.g. ``m.mean(ex0=True)`` returns the mean, excluding zero entries.

Besides, it is possible to get all collected values as a list with _x or as a numpy array as x().
Also, here exclude zero entries is an option.

Note that apart from _x, all the x-values are converted to a numeric value, if possible.
If not, 0 will be assumed.

With the monitor method, the monitor can be enbled or disabled. Note that a tally is just ignored when
the monitor is disabled.

Also, the current status (enabled/disabled) can be retrieved.

.. code-block:: python
    
    proctime.monitor(True)  # enable monitoring
    proctime.monitor(False)  # disable monitoring
    if proctime.monitor():
        print('proctime is enabled')

Calling m.reset() will clear all tallied values.

The statistics of a monitor can be printed with ``print_statistics()``. 
E.g: ``waitingline.length_of_stay.print_statistics()``:

.. code-block:: none

    Statistics of Length of stay in waitingline at     50000    
                            all    excl.zero         zero
    -------------- ------------ ------------ ------------
    entries            4995         4933           62    
    mean                 84.345       85.405
    std.deviation        48.309       47.672
    
    minimum               0            0.006
    median               94.843       95.411
    90% percentile      142.751      142.975
    95% percentile      157.467      157.611
    maximum             202.153      202.153    
    
And, a histogram can be printed with ``print_histogram()``. E.g.
``waitingline.length_of_stay.print_histogram(30, 0, 10)``:

.. code-block:: none

    Histogram of Length of stay in waitingline
                            all    excl.zero         zero
    -------------- ------------ ------------ ------------
    entries            4995         4933           62    
    mean                 84.345       85.405
    std.deviation        48.309       47.672
    
    minimum               0            0.006
    median               94.843       95.411
    90% percentile      142.751      142.975
    95% percentile      157.467      157.611
    maximum             202.153      202.153
    
               <=       entries     %  cum%
            0            62       1.2   1.2 |                                                                              
           10           169       3.4   4.6 ** |                                                                           
           20           284       5.7  10.3 ****    |                                                                      
           30           424       8.5  18.8 ******         |                                                               
           40           372       7.4  26.2 *****               |                                                          
           50           296       5.9  32.2 ****                     |                                                     
           60           231       4.6  36.8 ***                          |                                                 
           70           192       3.8  40.6 ***                             |                                              
           80           188       3.8  44.4 ***                                |                                           
           90           136       2.7  47.1 **                                   |                                         
          100           352       7.0  54.2 *****                                      |                                   
          110           491       9.8  64.0 *******                                            |                           
          120           414       8.3  72.3 ******                                                   |                     
          130           467       9.3  81.6 *******                                                          |             
          140           351       7.0  88.7 *****                                                                 |        
          150           224       4.5  93.2 ***                                                                       |    
          160           127       2.5  95.7 **                                                                          |  
          170            67       1.3  97.0 *                                                                            | 
          180            59       1.2  98.2                                                                               |
          190            61       1.2  99.4                                                                                |
          200            24       0.5  99.9                                                                                |
          210             4       0.1 100                                                                                   |
          220             0       0   100                                                                                   |
          230             0       0   100                                                                                   |
          240             0       0   100                                                                                   |
          250             0       0   100                                                                                   |
          260             0       0   100                                                                                   |
          270             0       0   100                                                                                   |
          280             0       0   100                                                                                   |
          290             0       0   100                                                                                   |
          300             0       0   100                                                                                   |
              inf         0       0   100     

MonitorTimestamp
^^^^^^^^^^^^^^^^
The MonitorTimestamp class collects value along with the current (simulation) time.
e.g. the number of parts a machine is working on.

Making your own monitorstamp is considerably more complicated than Monitors as it involves defining
a getter function. For applications, we therefore recommend to create a state and use the
value as a timestamped monitor.

There is whole set of statistical data available, which are all weighted with the duration:

* duration
* duration_zero (time that the value was zero)
* mean
* std
* minimum
* median
* maximum
* percentile 
* bin_count (number of entries between to given values)
* histogram (numpy definition)

For all these statistics, it is possible to exclude zero entries, e.g. ``m.mean(ex0=True)`` returns the mean, excluding zero entries.

Besides, it is possible to get all collected values as a list with _x and to get the associated timestamps with _t.

But, more useful is xduration(), which return a tuple of two numpy arrays: x-values and associated durations. |n|
The method xt() returns a tuple of two numpy arrays: x-values and associated timestamps. |n|
The method tx() returns a tuple of two numpy arrays: timestamps and associated x-values. |n|

When monitoring is disabled, a nan value will be tallied. All statistics will ignore the periods from
nan to a non-nan value. This also holds for the xduration() method, but NOT for xt() and tx(). Thus,
the x-arrays of xduration() are not necessarily the same as the x-arrays in xt() and tx(). This is
the reason why there's no x() or t() method. |n|
It is easy to get just the x-array with xduration[0].

Note that apart from _x, all the x-values are converted to a numeric value, if possible.
If not, 0 will be assumed.

With the monitor method, the timestamped monitor can be enbled or disabled.

Also, the current status (enabled/disabled) can be retrieved.

.. code-block:: python
    
    level.monitor(True)  # enable monitoring
    level.monitor(False)  # disable monitoring
    if level.monitor():
        print('level is enabled')

Calling m.reset() will clear all tallied values and timestamps.

The statistics of a timestamped monitor can be printed with ``print_statistics()``. 
E.g: ``waitingline.length.print_statistics()``:

.. code-block:: none

    Statistics of Length of waitingline at     50000    
                            all    excl.zero         zero
    -------------- ------------ ------------ ------------
    duration          50000        48499.381     1500.619
    mean                  8.427        8.687
    std.deviation         4.852        4.691
    
    minimum               0            1    
    median                9           10    
    90% percentile       14           14    
    95% percentile       16           16    
    maximum              21           21    
      
And, a histogram can be printed with ``print_histogram()``. E.g. ::

    waitingline.length.print_histogram(30, 0, 1)

.. code-block:: none

    Histogram of Length of waitingline
                            all    excl.zero         zero
    -------------- ------------ ------------ ------------
    duration          50000        48499.381     1500.619
    mean                  8.427        8.687
    std.deviation         4.852        4.691
    
    minimum               0            1    
    median                9           10    
    90% percentile       14           14    
    95% percentile       16           16    
    maximum              21           21    
    
               <=      duration     %  cum%
            0          1500.619   3.0   3.0 **|                                                                            
            1          2111.284   4.2   7.2 ***  |                                                                         
            2          3528.851   7.1  14.3 *****      |                                                                   
            3          4319.406   8.6  22.9 ******            |                                                            
            4          3354.732   6.7  29.6 *****                  |                                                       
            5          2445.603   4.9  34.5 ***                        |                                                   
            6          2090.759   4.2  38.7 ***                           |                                                
            7          2046.126   4.1  42.8 ***                               |                                            
            8          1486.956   3.0  45.8 **                                  |                                          
            9          2328.863   4.7  50.4 ***                                     |                                      
           10          4337.502   8.7  59.1 ******                                         |                               
           11          4546.145   9.1  68.2 *******                                               |                        
           12          4484.405   9.0  77.2 *******                                                      |                 
           13          4134.094   8.3  85.4 ******                                                              |          
           14          2813.860   5.6  91.1 ****                                                                    |      
           15          1714.894   3.4  94.5 **                                                                         |   
           16           992.690   2.0  96.5 *                                                                            | 
           17           541.546   1.1  97.6                                                                               |
           18           625.048   1.3  98.8 *                                                                              |
           19           502.291   1.0  99.8                                                                                |
           20            86.168   0.2 100.0                                                                                |
           21             8.162   0.0 100                                                                                   |
           22             0       0   100                                                                                   |
           23             0       0   100                                                                                   |
           24             0       0   100                                                                                   |
           25             0       0   100                                                                                   |
           26             0       0   100                                                                                   |
           27             0       0   100                                                                                   |
           28             0       0   100                                                                                   |
           29             0       0   100                                                                                   |
           30             0       0   100                                                                                   |
              inf         0       0   100  

Distributions
-------------
Salabim can be used with the standard random module, but it is easier to use the salabim distributions.

Internally, salabim uses the random module. There is always a seed associated with each distribution, which
is normally random.random. 

When a new environment is created, the random seed 1234567 will be set by default. However, it is possible to
override this behaviour with the random_seed parameter:

* any hashable value, to set another seed
* null string (''): no reseeding
* None: true random, non reproducible (based on current time)

As a distribution is an instance of a class, it can be used in assignment, parameters, etc. E.g. ::

    interarrivaltime = sim.Uniform(10,15)
    
And then, to wait for a time sampled from this distribution ::

    yield self.hold(interarrivaltime.sample())
    
All distributions support the following methods:

* mean()
* sample()
    
Salabim provides the following distribution classes:

Constant
^^^^^^^^
No sampling is required for this distribution, as it always returns the same value. E.g. ::

    processingtime = sim.Constant(10)

Uniform
^^^^^^^^
Uniform distribution between lowerbound and upperbound. E.g. ::

    processingtime = sim.Uniform(5, 15)

Triangular
^^^^^^^^^^
Triangular distribution between lowerbound and upperbound with a given median. E.g. ::

    processingtime = sim.Triangular(5, 15, 8)
    
Exponential
^^^^^^^^^^^
Exponential distribution with a given mean. E.g. ::

     interarrivaltime = sim.Exponential(10)  # on an average every 10 time units

Normal
^^^^^^
Normal distribution with a given mean and standard deviation. E.g. ::

    processingtime = sim.Normal(10, 2)
    
Note that this might result in negative values, which might not correct if it is a duration. In that case,
sample like ::

    yield self.hold(max(0,processingtime.sample())
    
Cdf
^^^
Cumulative distribution function, specified as a list x[i],p[i] values, where p[i] is the cumulative probability
that xn<=pn. E.g. ::

    processingtime = sim.Cdf(5, 0, 10, 50, 15, 90, 30, 95, 60, 100)
    
This means that 0% is <5, 50% is < 10, 90% is < 15, 95% is < 30 and 100% is <60.

.. note:: It is required that p[0] is 0 and that p[i]<=p[i+1] and that x[i]<=x[i+1].

It is not required that the last p[] is 100, as all p[]'s are automatically scaled. This means that the two distributions below are
identical to the first example ::

    processingtime = sim.Cdf(5, 0.00, 10, 0.50, 15, 0.90, 30, 0.95, 60, 1.00)
    processingtime = sim.Cdf(5,    0, 10,   10, 15,   18, 30,   19, 60,   20)

Pdf
^^^
Probability density function, specified as:

1. list or tuple of x[i], p[i] where p[i] is the probability (density)
2. list or tuple of x[i] followed by a list or tuple p[i]
3. list or tuple of x[i] followed by a scalar (value not important)

.. note:: It is required that the sum of p[i]'s is **greater than** 0.
  
E.g. ::

    processingtime = sim.Pdf(5, 10, 10, 50, 15, 40)

This means that 10% is 5, 50% is 10 and 40% is 40.

It is not required that the sum of the p[i]'s is 100, as all p[]'s are automatically scaled. This means that the two distributions below are
identical to the first example ::
    
    processingtime = sim.Pdf(5, 0.10, 10, 0.50, 15, 0.40) 
    processingtime = sim.Pdf(5,    2, 10,   10, 15,    8)

And the same with the second form ::

    processingtime = sim.Pdf((5, 10, 15), (10, 50, 40))

If all x[i]'s have the same probability, the third form is very useful ::
 
    dice = sim.Pdf((1,2,3,4,5,6),1)
    dice = sim.Pdf(range(1,7),1)  # same as above

x[i] may be of any type, so it possible to use ::

    color = sim.Pdf('Green', 45, 'Yellow', 10, 'Red', 45)
    cartype = sim.Pdf(ordertypes,1)
    
If the x-value is a salabim distribution, not the distribution but a sample of that distribution is returned when sampling ::

    processingtime = sim.Pdf(sim.Uniform(5, 10), 50, sim.Uniform(10, 15), 40, sim.Uniform(15, 20), 10)
    proctime=processingtime.sample()
    
Here proctime will have a probability of 50% being between 5 and 10, 40% between 10 and 15 and 10% between 15 and 20. 
    


  
Distribution
^^^^^^^^^^^^
A very special distribution is the Distribution class. Here, a string will contain the specification of the distribution.
This is particularly useful when the distributions are specified in an external file. E.g. ::

    with open('experiment1.txt', 'r') as f:
        interarrivaltime = sim.Distribution(read(f))
        processingtime = sim.Distribution(read(f))
        
With a file experiment.txt ::

    Uniform(10,15)
    Triangular(1,5,2)

Animation
---------
Animation is a very powerful tool to debug, test and demonstrate simulations.
Salabim's animation engine also allows some user input.

Salabim animations are always synchronized with the simulation clock and run in real time.
One time unit in the simulation can correspond to any period in real time, e.g.

* 1 time unit in simulation time --> 1 second real time (speed = 1) (default)
* 1 time unit in simulation time --> 4 seconds real time (speed = 0.25)
* 4 time units in simulation time --> 1 second real time (speed = 4)

In order to run an animated simulation at least one call to ``animation_parameters`` had to be
issued. And then upon the next run statement, the animation will start.

The animation uses a coordinate system that -by default- is in screen pixels. The lower left corner is (0,0).
But, the user can change both the coordinate of the lower left corner (translation) as well as set the x-coordinate
of the lower right hand corner (scaling). Note that x- and y-scaling are always the same. |n|
Furthermore, it is possible to specify the colour of the background with ``animation_parameters``. 

The animation is started with a ``run`` statement.

There is actually just one animation object class: Animate. This class can be used to show:

* line (if line0 is specified)
* rectangle (if rectangle0 is specified) 
* polygon (if polygon0 is specified)
* circle (if circle0 is specified)
* text (if text is specified)
* image (if image is specicified)

Note that only one type is allowed per instance of Animate. 

Nearly all attributes of an Animate object are interpolated between time t0 and t1.
If t0 is not specified, now() is assumed.
If t1 is not specified inf is assumed, which means that the attribute will be the '0' attribute. 

E.g.:

``Animate(x0=100,y0=100,rectangle0==(-10,-10,10,10))`` will show a square around (100,100) for ever |n|
``Animate(x0=100,y0=100,x1=200,y1=0,rectangle0=(-10,-10,10,10))`` will still show the same square around (100,100) as t1 is not specified |n|
``Animate(t1=env.now()+10,x0=100,y0=100,x1=200,y1=0,rectangle0=(-10,-10,10,10))`` will show a square moving from (100,100) to (200,0) in 10 units of time. |n|

It also possible to let the rectangle change shape over time:

``Animate(t1=env.now(),x0=100,y0=100,x1=200,y1=0,rectangle0=(-10,-10,10,10),rectangle1=(-20,-20,20,20))`` will show a moving and growing rectangle. |n|

By default, the animation object will not change anymore after t1, but will remain visible. Alternatively, if
keep=False is specified, the object will disappear at time t1.

Also, colors, fontsizes, angles can be changed in a linear way over time. 

E.g.:

``Animate(t1=env.now()+10,text='Test',textcolor0='red',textcolor1='blue',angle0=0,angle1=360)`` will show a rotating text changing from red to blue in 10 units of time.

The animation object can be updated with the update method. Here, once again, all the attributes can be specified to change over time. Note that the defaults for the '0' values are the actual values at t=now().

Thus,

``an=Animate(t0=0,t1=10,x0=0,x1=100,y0=0,circle0=(10,),circle1=(20,))``
will show a horizontally moving, growing circle.

Now, at time t=5, we issue
``an.update(t1=10,y1=50,circle1=(10,))``
Then x0 will be set 50 (halfway 0 an 100) and cicle0 to (15,) (halfway 10 and 20).
Thus the circle will shrink to its original size and move vertically from (50,0) to (50,50).
This concept is very useful for moving objects whose position and orientation are controlled by the simulation.

Here we explain how an attribute changes during time. We use x as an example.
Normally, x=x0 at t=t0 and x=x1 at t>=t1. between t=t0 and t=t1, x is linearly interpolated.
An application can however override the x method. The prefered way is to subclass the Animate class:

.. literalinclude:: ..\..\Demo animate 1.py
           
This code will show the current simulation time moving from left to right, uniformly accelerated.
And the text will be shown a bit higher up, every second. It is not necessary to use t0, t1, x0, x1, but
is a convenient way of setting attributes.

The following methods may be overridden:

======================  ========= ========= ========= ========= ========= =========
method                  circle    image     line      polygon   rectangle text
======================  ========= ========= ========= ========= ========= =========
anchor                            -                                       -
angle                   -         -         -         -         -         -
circle                  -
fillcolor               -                             -         -
fontsize                                                                  -
image                             -
layer                   -         -         -         -         -         -
line                                        -
linecolor               -                   -         -         -
linewidth               -                   -         -         -
offsetx                 -         -         -         -         -         -
offsety                 -         -         -         -         -         -
polygon                                               -
rectangle                                                       -
text                                                                      -
textcolor                                                                 -
visible                 -         -         -         -         -         -
width                             -
x                       -         -         -         -         -         -
y                       -         -         -         -         -         -
======================  ========= ========= ========= ========= ========= =========

*Dashboard animation*

Here we present an example model where the simulation code is completely separated from the animation code.
This makes communication and debugging and switching off animation much easier.

The example below generates 15 persons starting at time 0, 1, ... . These persons enter a queue called q and
stay there 15 time units.

The animation dashboard shows the first 10 persons in the queue q, along with the length of that q.

.. literalinclude:: ..\..\Demo animate 2.py

All animation initialization is in ``do_animation``, where first 10 rectangle and text Animate
objects are created. These are classes that are inherited from sim.Animate.

The AnimateWaitSquare defines a red rectangle at a specific position in the ``sim.Animate.__init__()`` call.
Note that normally these squares should be displayed. But, here we have overridden the visible method.
If there is no i-th component in the q, the square will be made invisible. Otherwise, it is visible.

The AnimateWaitText is more or less defined in a similar way. It defines a text in white at a specific position.
Only the text method is overridden and will return the name of the i-th component in the queue, if any. Otherwise 
the null string will be returned.

The length of the queue q could be defined also by subclassing sim.Animate, but here we just make a direct instance
of Animate with the null string as the text to be displayed. And then we immediately override the text method with 
a lambda function. Note that in this case, self is not available!


Video production
----------------
An animation can be recorded as an .mp4 video by sprecifying ``video=filename`` in the call to animation_parameters.
The effect is that 30 time per second (scaled animation time) a frame is written. In this case, the animation does not
run synchronized with the wall clock anymore. Depending on the complexity of the animation, the simulation might run
faster of slower than real time. Other than with an ordinary animation, frames are never skipped.

Once control is given back to main, the .mp4 file is closed.

Contributing to salabim
-----------------------
If you would like to contribute to salabim, please send a pull request to GitHb.

Reference
---------

.. automodule:: salabim
   :members:
 
Indices and tables
==================

* :ref:`genindex`
* :ref:`search`

